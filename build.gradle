import groovy.text.SimpleTemplateEngine
import java.util.Properties
import java.io.FileWriter
import org.apache.commons.io.FileUtils

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'commons-io:commons-io:2.4'
    }
}

def createTemplate = { template_path, destination_path ->

    logger.quiet "~> Starting templating engine, from template [${template_path}]"

    //--------- [Loading step] ---------//

    def engine = new SimpleTemplateEngine()
    def props  = new Properties()

    // Loading template properties
    props.load(new FileInputStream(file('template-engine.properties')))
    def bindings = [:]
    props.propertyNames().each{ prop->
        bindings[prop] = props.getProperty(prop)
    }
    bindings["YEAR"] = Calendar.getInstance().get(Calendar.YEAR)

    // APPNAME - ensure that the string is in lower case with first letter in upper case
    bindings["APPNAME"] = bindings["APPNAME"][0].toUpperCase() + bindings["APPNAME"][1..-1].toLowerCase()

    destination_path = destination_path + "/" + bindings["APPNAME"]

    logger.quiet "~> [Loading] Destination : ${destination_path}"

    logger.quiet "~> [Loading] Properties file loaded."

    // Loading ignore list
    // If a line begins with >, then the file is completely ignored.
    // Otherwise, the file is copied without being parsed.
    def ignored_directories     = []
    def ignored_files           = []
    def unparsed_directories    = []
    def unparsed_files          = []

    def template_ignore = file("${template_path}/template-engine-ignore")

    template_ignore.eachLine{ line ->
        def full_path = "${template_path}/${line}"
        if(line.length() > 0 && file(full_path).isDirectory())
            if(line[0] == '>')
                ignored_directories.add(full_path[1..-1])
            else
                unparsed_directories.add(full_path)
        else if(line.length() > 0)
            if(line[0] == '>')
                ignored_files.add(line[1..-1])
            else
                unparsed_files.add(line)
    }

    def isIgnoredDirectory = { dir ->
        ignored_directories.any{ d -> file(d).getAbsolutePath().equals(dir.getAbsolutePath()) }
    }
    def isIgnoredFile = { file ->
        ignored_files.contains(file.name)
    }
    def isUnparsedDirectory = { dir ->
        unparsed_directories.any{ d -> file(d).getAbsolutePath().equals(dir.getAbsolutePath()) }
    }
    def isUnparsedFile = { file ->
        unparsed_files.contains(file.name)
    }

    logger.quiet "~> [Loading] Ignore file loaded."

    //--------- [Generating step] ---------//

    // Creating destination directory
    file("${destination_path}").mkdir()

    // Apply recursively an action to all files & folders, children of baseDir.
    def recursiveApply
    recursiveApply = { baseDir, action, path = '' ->
        baseDir.listFiles().each{ file ->
            def newpath = action(path, file)
            if(file.isDirectory() && !isIgnoredDirectory(file) && !isUnparsedDirectory(file))
                recursiveApply(file, action, "${newpath}")
        }
    }

    // Templating action to apply to a file or a directory, may return a modified path.
    def generateTemplateAction = { path, fileitem ->

        logger.quiet "~> [Generating] ${path}${fileitem.name} to ${destination_path}/${path}"

        def directoryAction = { dir ->
            if(bindings.containsKey(dir.name)){
                //Special names that modify path.
                def newDirectories = bindings[dir.name].replaceAll("[.]", "/").toLowerCase()
                logger.quiet "------- ${dir.name} => ${newDirectories}"
                file("${destination_path}/${path}${newDirectories}").mkdirs()
                "${path}${newDirectories}/"
            } else {
                //Regular names.
                file("${destination_path}/${path}${dir.name}").mkdir()
                "${path}${dir.name}/"
            }
        }
        def fileAction = { file ->
            def specialName = bindings.find{ k, v -> file.name.contains(k) }
            def destinationFile
            if(specialName != null){
                //Html file in lower case
                if(file.name.contains('html')){
                    destinationFile = new File("${destination_path}/${path}${file.name.replaceAll(specialName.key, specialName.value.toLowerCase())}")
                    logger.quiet "------- ${file.name} => ${file.name.replaceAll(specialName.key, specialName.value.toLowerCase())}"
                } else {
                    destinationFile = new File("${destination_path}/${path}${file.name.replaceAll(specialName.key, specialName.value)}")
                    logger.quiet "------- ${file.name} => ${file.name.replaceAll(specialName.key, specialName.value)}"
                }
            } else
                destinationFile = new File("${destination_path}/${path}${file.name}")
            def output = engine.createTemplate(file).make(bindings)
            def fileWriter = new FileWriter(destinationFile)
            fileWriter.write(output.toString())
            fileWriter.close()

            path
        }

        //TODO : REGEX COMPARISON
        if(fileitem.isDirectory())
            if(isIgnoredDirectory(fileitem)){
                logger.quiet "\t(${fileitem.name} : Ignored)"
                "${path}${fileitem.name}/"
            } else if(isUnparsedDirectory(fileitem)) {
                //Copy the directory contents
                FileUtils.copyDirectory(fileitem, file("${destination_path}/${path}${fileitem.name}"))
                logger.quiet "\t(${fileitem.name} : Unparsed)"
                "${path}${fileitem.name}/"
            } else {
                directoryAction(fileitem)
            }
        else
            if(isIgnoredFile(fileitem)){
                logger.quiet "\t(${fileitem.name} : Ignored)"
                path
            } else if(isUnparsedFile(fileitem)) {
                //Copy the file
                FileUtils.copyFile(fileitem, file("${destination_path}/${path}${fileitem.name}"))
                logger.quiet "\t(${fileitem.name} : Unparsed)"
                "${path}${fileitem.name}"
            } else {
                fileAction(fileitem)
            }
    }

    // Start processing
    recursiveApply(file("${template_path}"), generateTemplateAction)

}

task buildArchetype(description:'Generate a new project based on templates') << {

    def console = System.console()

    //*--------- [Utility methods] ---------//

    def integer_check = { min, max, str ->
        try{
            def i = Integer.parseInt(str)
            i > min && i < max
        } catch(e){
            false
        }
    }

    def getValidatedInput = { condition, message, errormessage, postAction = {x -> x} ->
        def result = ""
        while(true){
            result = console.readLine(message)
            if(condition(result))
                break
            logger.error errormessage
        }
        postAction(result)
    }

    //-------------------------------------/*/

    def separator = "------------------------------------------------------------------"
    def templates = file('templates').listFiles().toList()
    def displayTemplates = []
    templates.eachWithIndex{ file , i -> displayTemplates.add("(${i}) : ${file.name}") }

    if(console) {
        println separator
        println(displayTemplates)
        def TEMPLATE_NUMBER = getValidatedInput(
                integer_check.curry(-1, templates.size()),
                '~> Please enter the template number : ',
                "!> Please enter a valid number.",
                { result -> Integer.parseInt(result) }
        )
        def DESTINATION_PATH = getValidatedInput(
                { path -> file(path).exists() },
                '~> Please enter the destination directory : ',
                "!> Please enter a valid path.')"
        )

        createTemplate(templates[TEMPLATE_NUMBER], DESTINATION_PATH)
    } else {
        logger.error "!> Cannot get console."
    }

}
